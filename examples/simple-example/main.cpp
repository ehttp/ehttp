#include <string>
#include <iostream>
#include <ehttp/server.h>
#include <ehttp/parser.h>
#include <ehttp/request.h>
#include <ehttp/response.h>

using namespace ehttp;

int main(int argc, const char **argv)
{
	// Make a server, and a map of parsers corresponding to them
	server srv;
	std::map<std::shared_ptr<server::connection>, std::shared_ptr<parser>> parsers;
	
	
	
	// Create and destroy parsers in the connection and disconnection handlers
	srv.on_connected = [&](std::shared_ptr<server::connection> connection) {
		std::cout << "> Connected!" << std::endl;
		parsers[connection] = std::make_shared<parser>();
	};
	srv.on_disconnected = [&](std::shared_ptr<server::connection> connection) {
		std::cout << "> Disconnected!" << std::endl;
		parsers.erase(connection);
	};
	
	
	
	// Handle data received on connections
	srv.on_data = [&](std::shared_ptr<server::connection> connection, void *data, std::size_t size) {
		// If you want to log the raw received data:
		//std::cout << std::string(static_cast<char*>(data), size) << std::endl;
		
		// Grab the connection's parser and feed it the received data
		std::shared_ptr<parser> parser = parsers[connection];
		if(parser->parse_chunk(data, size) == parser::got_request)
		{
			auto req = parser->request();
			auto res = std::make_shared<response>(req);
			
			std::cout << "Got a request for " << req->url << std::endl;
			
			// Log data being written, before just feeding it to the connection
			res->on_head = [=](std::shared_ptr<response> res, std::vector<char> data) {
				std::cout << "--> on_head" << std::endl;
				std::cout << std::string(data.begin(), data.end()) << std::endl;
				connection->write(data);
			};
			res->on_body = [=](std::shared_ptr<response> res, std::vector<char> data) {
				std::cout << "--> on_body" << std::endl;
				std::cout << std::string(data.begin(), data.end()) << std::endl;
				connection->write(data);
			};
			res->on_chunk = [=](std::shared_ptr<response> res, std::shared_ptr<response::chunk> chunk, std::vector<char> data) {
				std::cout << "--> on_chunk" << std::endl;
				std::cout << std::string(data.begin(), data.end()) << std::endl;
				connection->write(data);
			};
			res->on_end = [=](std::shared_ptr<response> res) {
				std::cout << "--> on_end" << std::endl;
			};
			
			// Begin the response; status codes other than 200 can be given as
			// `begin(404)`, custom reasons as `begin(500, "Man Overboard")`.
			res->begin()
				
				// Write a header; this should be done before writing anything,
				// as attempting to change a header after calling end() or even
				// write() on a chunked connection will throw an exception.
				// The Date and Content-Length headers are autogenerated.
				->header("Content-Type", "text/plain")
				
				// Uncomment to make the response chunked, and cause write() to
				// write chunks rather than append to the body. This will also
				// set the Transfer-Encoding header, and write out any already
				// written body data as the first chunk.
				//->make_chunked()
				
				// Write some data!
				->write("Lorem ipsum dolor sit amet")
				
				// You can also explicitly create chunks; writing one out with
				// end_chunk() will automatically make the response chunked if
				// it's not already, by calling make_chunked() on it.
				/*
				->begin_chunk()
					->write("Lorem ipsum dolor sit amet")
					->end_chunk()
				*/
				
				// End the response and send it to the browser, or write a
				// terminating chunk for a chunked connection. Attempting to
				// modify anything after calling end() will throw an exception.
				->end();
		}
	};
	
	// Optionally log any technical errors that occur (network issues, etc)
	srv.on_error = [](asio::error_code error) {
		std::cerr << "Error: " << error.message() << std::endl;
	};
	
	
	
	/* 
	 * Attempt to bind to (listen on) a TCP port; this is one of the things
	 * that are most prone to failing, so even if you have no other error
	 * checking code, at least check this one, otherwise your server will
	 * silently fail to start if anything goes wrong.
	 * 
	 * A few examples of cases where listen() may fail:
	 * - Another application is running on the same port
	 * - Another instance of your application is already running
	 * - Your application crashed, and the OS hasn't unbound its port yet
	 * - You don't have permission to open that port
	 * - You're on Windows, and your firewall or antivirus is messing with you
	 * - The underlying implementation may be bugged on your platform
	 * - Something unrelated to your application just started malfunctioning
	 * 
	 * While you can't be expected to be held responsible for any of these, you
	 * are expected to log an error and return failure if you can't bind,
	 * rather than just silently malfunctioning.
	 */
	asio::error_code error = srv.listen(8080);
	if(!error)
	{
		// If it succeeds, log something happy and run until terminated
		std::cout << "Listening!" << std::endl;
		srv.run();
	}
	else
	{
		// Report an error and exit with a nonzero status if it fails
		std::cout << "Couldn't listen: " << error.message() << std::endl;
		return 1;
	}
	
	return 0;
}
